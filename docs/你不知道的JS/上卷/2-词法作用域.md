### 词法阶段

```js
// 包含着整个全局作用域，其中只有一个标识符： foo 。
function foo(a) {
  // 包含着 foo 所创建的作用域，其中有三个标识符： a 、 bar 和 b 。
  var b = a * 2;

  function bar(c) {
    // 包含着 bar 所创建的作用域，其中只有一个标识符： c 。
    console.log(a, b, c);
  }

  bar(b * 3);
}

foo(2); // 2, 4, 12
```

查找: 作用域查找会在找到第一个匹配的标识符时停止。 在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见 第一个匹配的标识符为止。

### 欺骗词法

如果词法作用域完全由写代码期间函数所声明的位置来定义， 怎样才能在运行时来“修 改”（也可以说欺骗）词法作用域呢？

1.  eval

```js
function foo(str, a) {
  eval(str); // 欺骗！
  // 这段代码实际上在 foo(..) 内部创建了一个变量 b

  console.log(a, b);
}
var b = 2;
foo('var b = 3;', 1); // 1, 3
```

在严格模式的程序中， eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。

```js
function foo(str) {
  'use strict';
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}

foo('var a = 2');
```

1.  with

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以 不需要 重复引用对象 本身。

```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = { a: 3 };

var o2 = { b: 3 };

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined // o2 并没有 a 属性， 因此不会创建这个属性
console.log(a); // 2——不好，a 被泄漏到全局作用域上了！
```

1.  性能

JavaScript 引擎会在编译阶段进行数项的性能优化。 其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符。

但如果引擎在代码中发现了 eval(..) 或 with ， 它只能简单地 假设 关于标识符位置的判断 都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会 如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底 是什么。
