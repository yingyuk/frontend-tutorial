### 编译原理

1.  分词/词法分析（Tokenizing/Lexing）

    ```js
    var a = 2;
    ```

    这段程序通常会被分解成 为下面这些词法单元： `var` 、 `a` 、 `=` 、 `2` 、 `;` 。

1.  解析/语法分析（Parsing）

1.  代码生成

### 理解作用域

1.  演员表

    - 引擎

      从头到尾负责整个 JavaScript 程序的编译及执行过程。

    - 编译器

      引擎的好朋友之一，负责语法分析及代码生成等脏活累活（详见前一节的内容）。

    - 作用域

      引擎的另一位好朋友， 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

1.  对话


    ```js
    var a = 2;
    ```

    1.  遇到 var a ，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的 集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作 用域的集合中声明一个新的变量，并命名为 a 。

    1.  接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值 操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 a 的 变量。 如果是， 引擎就会使用这个变量；如果否， 引擎会继续查找该变量（查看 1.3 节）。

1.  编译器有话说

    LHS 赋值操作的目标是谁;
    RHS 理解成 retrieve his source value（取到它的源值）

    ```js
    console.log(a);
    // 其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取 得 a 的值，这样才能将值传递给 console.log(..) 。

    a = 2;
    // 这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。
    ```

1.  引擎和作用域的对话

    ```js
    function foo(a) {
      console.log(a); // 2
    }

    foo(2);

    // 引擎：我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？
    // 作用域：别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。
    // 引擎：哥们太够意思了！好吧，我来执行一下 foo 。
    // 引擎：作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？
    // 作用域：这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。
    // 引擎：大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a 。
    // 引擎：哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？
    // 作用域：咱俩谁跟谁啊，再说我就是干这个。这个我也有， console 是个内置对象 给你。
    // 引擎：么么哒。我得看看这里面是不是有 log(..) 。太好了，找到了，是一个函数。
    // 引擎：哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。
    // 作用域：放心吧，这个变量没有变动过，拿走，不谢。
    // 引擎：真棒。我来把 a 的值，也就是 2 ，传递进 log(..)
    ```

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。

### 异常

为什么区分 LHS 和 RHS 是一件重要的事情？

因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行 为是不一样的。

```js
function foo(a) {
  // 第一次对 b 进行 RHS 查询时是无法找到该变量的。 也就是说， 这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它。
  console.log(a + b);

  // 相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中 就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。
  // window.b = a;
  b = a;
}

foo(2);
```

ES5 中引入了“严格模式”。在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。

接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。

ReferenceError 同作用域判别失败相关， 而 TypeError 则代表作用域判别成功了， 但是对 结果的操作是非法或不合理的。

### 小结

如果查找的目的是对 变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。
